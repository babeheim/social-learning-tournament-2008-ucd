
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%Round 1 and 2: Observe
%
%Other rounds: 
%
% a)Check to see if the population is cycling between learning and
%   exploiting, if so join cycle, if not play WOOT V 3 good
%
% b) If not cycling, exploit unless payoff decreases below median payoff,
% then switch to best payoff in rep
%
% c) Stochasically observe if last two payoffs are below median payoff
%       
%
%Matt Zimmerman with a base of code by Ryan Boyko with base of code by Matt Zimmerman
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


function [move, myRep]=observe_twice_then_exploit_cycle(roundsAlive, myRepertoire, myHistory)

if (roundsAlive==0) || (roundsAlive==1) %first or second round
    move=0; % observe

elseif (roundsAlive > 2) && ((myHistory(3,roundsAlive-1)==0)) %if three rounds ago, no one exploited, then this round exploit highest payoff.
     orderedRep = sortrows([myRepertoire'],2);
     move=orderedRep(size(orderedRep,1),1);
    
elseif (roundsAlive > 2) && ((myHistory(3,roundsAlive)==0)) %two rounds ago no one exploited, then this round, innovate or observe.
    
    if rand<.5
        move=-1;
    else
        move=0;
    end
    
elseif size(myRepertoire, 2)<2 % if the population doesn't look like it is cycling, make sure you have two moves in repitoire
     
    move=0;
    
elseif myHistory(2,size(myHistory,2))<1 %if you innovated or observed on the previous turn play highest value in repitoire
    
    orderedRep = sortrows([myRepertoire'],2);
    move=orderedRep(size(orderedRep,1),1);
    
else
     move=myHistory(3,size(myHistory,2)); %repeat the last move
     payoffs = myHistory(4,1:size(myHistory, 2)); %makes a vector of previous payoffs
     ordered_payoffs = sortrows([payoffs]'); %orders the payoffs
     
     if mod(size(ordered_payoffs),2)==0 %if there are an even number of payoffs
         med_payoff = (ordered_payoffs(size(ordered_payoffs)/2)+ordered_payoffs(size(ordered_payoffs)/2+1))/2; %calculate the median payoff
     else
         med_payoff = ordered_payoffs(ceil(size(ordered_payoffs)/2)); %otherwise calculate it anotherway
     end
     
     if myHistory(4,size(myHistory,2)) < med_payoff(1) %if the last payoff was less than the median payoff
        orderedRep = sortrows([myRepertoire'],2);
        best_move=orderedRep(size(orderedRep,1),1);
        best_exp_payoff=orderedRep(size(orderedRep,1),2); %play best move in Rep       
        
        if best_exp_payoff < med_payoff(1)
            
            choice=rand;
            if choice > (best_exp_payoff/med_payoff(1))
                move = 0;
            else
                move = best_move;
            end
        else
            move=best_move;
        end
     end
end
     
myRep=myRepertoire;